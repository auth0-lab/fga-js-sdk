/* tslint:disable */
/* eslint-disable */
/**
 * Auth0 Fine Grained Authorization (FGA)
 * Auth0 Fine Grained Authorization (FGA) is an early-stage product we are building at Auth0 as part of Auth0Lab to solve fine-grained authorization at scale. If you are interested in learning more about our plans, please reach out via our Discord chat.  The limits and information described in this document is subject to change.
 *
 * The version of the OpenAPI document: 0.1
 * Contact: https://discord.gg/8naAwJfWN6
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosInstance } from 'axios';

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @class InvalidEnvironmentError
 * @extends {Error}
 */
export class InvalidEnvironmentError extends Error {
    name: "InvalidEnvironmentError" = "InvalidEnvironmentError";
    constructor(public field: string, allowedEnvironments?: string[]) {
        super(allowedEnvironments ? `environment is required and must be one of the following: ${allowedEnvironments.join(', ')}` : undefined);
    }
}

/**
 *
 * @throws {RequiredError}
 * @export
 */
export const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
}

export interface UserConfigurationParams {
    storeId: string;
    clientId: string;
    clientSecret: string;
    environment?: string;
    baseOptions?: any;
}

export interface EnvironmentConfiguration {
    host: string;
    scheme: string;
    apiTokenIssuer: string;
    apiAudience: string;
    allowNoAuth?: boolean;
}

const environmentConfigurationString = `{"default":{"apiAudience":"https://api.us1.fga.dev/","apiTokenIssuer":"fga.us.auth0.com","scheme":"https","host":"api.us1.fga.dev"},"us":{"apiAudience":"https://api.us1.fga.dev/","apiTokenIssuer":"fga.us.auth0.com","scheme":"https","host":"api.us1.fga.dev"},"playground":{"allowNoAuth":true,"apiAudience":"https://api.playground.fga.dev/","apiTokenIssuer":"sandcastle-dev.us.auth0.com","scheme":"https","host":"api.playground.fga.dev"},"staging":{"apiAudience":"https://api.staging.fga.dev/","apiTokenIssuer":"sandcastle-dev.us.auth0.com","scheme":"https","host":"api.staging.fga.dev"},"poc":{"apiAudience":"https://api.poc.sandcastle.cloud","apiTokenIssuer":"sandcastle-dev.us.auth0.com","scheme":"https","host":"api.poc.sandcastle.cloud"}}`;

/**
 *
 * @throws {InvalidEnvironmentError}
 * @param environment - Environment from user config
 * @return EnvironmentConfiguration
 */
const getEnvironmentConfiguration = function (environment: string = 'default'): EnvironmentConfiguration {
  let environmentConfigs;
  try {
    environmentConfigs = JSON.parse(environmentConfigurationString);
  } catch (err) {
    throw new InvalidEnvironmentError(environment);
  }

  const environmentConfig = environmentConfigs[environment];

  if (environmentConfig) {
    return environmentConfig;
  }

  const allowedEnvs = Object.keys(environmentConfigs);

  throw new InvalidEnvironmentError(environment, allowedEnvs);
};

interface BaseOptions {
    headers: Record<string, string>;
}

export class Configuration {
    private accessToken?: string;
    private accessTokenExpiryDate?: Date;
    /**
     * provide server url
     *
     * @type {string}
     * @memberof Configuration
     */
    serverUrl: string;
    /**
     * provide storeId
     *
     * @type {string}
     * @memberof Configuration
     */
    storeId: string;
    /**
     * Auth0 FGA Client ID
     *
     * @type {string}
     * @memberof Configuration
     */
    clientId?: string;
    /**
     * Auth0 FGA Client Secret
     *
     * @type {string}
     * @memberof Configuration
     */
    clientSecret?: string;
    /**
     * Auth0 FGA API Token Issuer
     *
     * @type {string}
     * @memberof Configuration
     */
    apiTokenIssuer?: string;
    /**
     * Auth0 FGA API Audience
     *
     * @type {string}
     * @memberof Configuration
     */
    apiAudience?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: BaseOptions;

    constructor(params: UserConfigurationParams = {} as unknown as UserConfigurationParams, private axios: AxiosInstance = globalAxios) {
        assertParamExists('Configuration', 'storeId', params.storeId);

        const environmentConfiguration = getEnvironmentConfiguration(params.environment);

        this.storeId = params.storeId!;
        this.clientId = params.clientId;
        this.clientSecret = params.clientSecret;
        const baseOptions = params.baseOptions || {};
        baseOptions.headers = baseOptions.headers || {};

        this.serverUrl = `${environmentConfiguration.scheme}://${environmentConfiguration.host}`;
        this.apiTokenIssuer = environmentConfiguration.apiTokenIssuer;
        this.apiAudience = environmentConfiguration.apiAudience;
        this.baseOptions = baseOptions;

        if (!environmentConfiguration.allowNoAuth) {
            assertParamExists('Configuration', 'clientId', this.clientId);
            assertParamExists('Configuration', 'clientSecret', this.clientSecret);
        }
    }

    /**
     * Get access token, request a new one if not cached or expired
     * @return string
     */
    public async getAccessToken() {
      if (this.accessToken && (!this.accessTokenExpiryDate || this.accessTokenExpiryDate > new Date())) {
        return this.accessToken;
      }

      return this.requestAccessToken();
    }

    /**
     * Request new access token
     * @return string
    */
    private async requestAccessToken() {
      if (!this.clientId) {
        return '';
      }

      const response = await this.axios.post(`https://${this.apiTokenIssuer}/oauth/token`, {
        client_id: this.clientId,
        client_secret: this.clientSecret,
        audience: this.apiAudience,
        grant_type: 'client_credentials',
      });

      this.accessToken = response.data.access_token;
      this.accessTokenExpiryDate = new Date(Date.now() + response.data.expires_in);

      return this.accessToken;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
