/* tslint:disable */
/* eslint-disable */
/**
 * Sandcastle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: https://discord.gg/8naAwJfWN6
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosInstance } from 'axios';

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @class InvalidEnvironmentError
 * @extends {Error}
 */
export class InvalidEnvironmentError extends Error {
    name: "InvalidEnvironmentError" = "InvalidEnvironmentError";
    constructor(public field: string, allowedEnvironments?: string[]) {
        super(allowedEnvironments ? `environment is required and must be one of the following: ${allowedEnvironments.join(', ')}` : undefined);
    }
}

/**
 *
 * @throws {RequiredError}
 * @export
 */
export const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
}

export interface UserConfigurationParams {
    tenant: string;
    clientId: string;
    clientSecret: string;
    environment: string;
    deploymentId?: string;
    baseOptions?: any;
}

export interface EnvironmentConfiguration {
    host: string;
    scheme: string;
    apiTokenIssuer: string;
    apiAudience: string;
    deploymentId: string;
    requireAuth?: boolean;
}

const environmentConfigurationString = `{"playground":{"host":"api.playground.sandcastle.cloud","scheme":"https","apiTokenIssuer":"sandcastle-dev.us.auth0.com","apiAudience":"https://api.playground.sandcastle.cloud"},"staging":{"host":"api.staging.sandcastle.cloud","scheme":"https","apiTokenIssuer":"sandcastle-dev.us.auth0.com","apiAudience":"https://api.staging.sandcastle.cloud","requireAuth":true}}`;

/**
 *
 * @throws {InvalidEnvironmentError}
 * @param environment - Environment from user config
 * @return EnvironmentConfiguration
 */
const getEnvironmentConfiguration = function (environment: string): EnvironmentConfiguration {
  let environmentConfigs;
  try {
    environmentConfigs = JSON.parse(environmentConfigurationString);
  } catch (err) {
    throw new InvalidEnvironmentError(environment);
  }

  const environmentConfig = environmentConfigs[environment];

  if (environmentConfig) {
    return environmentConfig;
  }

  const allowedEnvs = Object.keys(environmentConfigs);

  throw new InvalidEnvironmentError(environment, allowedEnvs);
};

export class Configuration {
    private accessToken?: string;
    private accessTokenExpiryDate?: Date;
    /**
     * provide server url
     *
     * @type {string}
     * @memberof Configuration
     */
    serverUrl: string;
    /**
     * provide tenant
     *
     * @type {string}
     * @memberof Configuration
     */
    tenant: string;
    /**
     * Sandcastle Client ID
     *
     * @type {string}
     * @memberof Configuration
     */
    clientId?: string;
    /**
     * Sandcastle Client Secret
     *
     * @type {string}
     * @memberof Configuration
     */
    clientSecret?: string;
    /**
     * Sandcastle API Token Issuer
     *
     * @type {string}
     * @memberof Configuration
     */
    apiTokenIssuer?: string;
    /**
     * Sandcastle API Audience
     *
     * @type {string}
     * @memberof Configuration
     */
    apiAudience?: string;
    /**
     * Sandcastle Deployment ID
     *
     * @type {string}
     * @memberof Configuration
     */
    deploymentId?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;

    constructor(params: UserConfigurationParams = {} as unknown as UserConfigurationParams, private axios: AxiosInstance = globalAxios) {
        assertParamExists('Configuration', 'tenant', params.tenant);
        assertParamExists('Configuration', 'environment', params.environment);

        const environmentConfiguration = getEnvironmentConfiguration(params.environment);

        this.tenant = params.tenant;
        this.clientId = params.clientId;
        this.clientSecret = params.clientSecret;
        this.deploymentId  = params.deploymentId;
        const baseOptions = params.baseOptions || {};
        baseOptions.headers = baseOptions.headers || {};

        this.serverUrl = `${environmentConfiguration.scheme}://${environmentConfiguration.host}`;
        this.apiTokenIssuer = environmentConfiguration.apiTokenIssuer;
        this.apiAudience = environmentConfiguration.apiAudience;

        if (this.deploymentId) {
          baseOptions.headers['X-SANDCASTLE-DEPLOYMENT-ID'] = this.deploymentId;
        }
        this.baseOptions = baseOptions;

        if (environmentConfiguration.requireAuth) {
            assertParamExists('Configuration', 'clientId', this.clientId);
            assertParamExists('Configuration', 'clientSecret', this.clientSecret);
        }
    }

    /**
     * Get access token, request a new one if not cached or expired
     * @return string
     */
    public async getAccessToken() {
      if (this.accessToken && (!this.accessTokenExpiryDate || this.accessTokenExpiryDate > new Date())) {
        return this.accessToken;
      }

      return this.requestAccessToken();
    }

    /**
     * Request new access token
     * @return string
    */
    private async requestAccessToken() {
      if (!this.clientId) {
        return '';
      }

      const response = await this.axios.post(`https://${this.apiTokenIssuer}/oauth/token`, {
        client_id: this.clientId,
        client_secret: this.clientSecret,
        audience: this.apiAudience,
        grant_type: 'client_credentials',
      });

      this.accessToken = response.data.access_token;
      this.accessTokenExpiryDate = new Date(Date.now() + response.data.expires_in);

      return this.accessToken;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
