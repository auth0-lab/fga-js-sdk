/* tslint:disable */
/* eslint-disable */
/**
 * Sandcastle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: https://discord.gg/8naAwJfWN6
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

import { COLLECTION_FORMATS, BaseAPI } from './base';
import {
    DUMMY_BASE_URL,
    setBearerAuthToObject,
    setSearchParams,
    serializeDataIfNeeded,
    toPathString,
    createRequestFunction,
    RequestArgs,
    PromiseResult
} from './common';
import { assertParamExists, Configuration, RequiredError } from './configuration';

/**
 * 
 * @export
 * @interface NamespaceDifference
 */
export interface NamespaceDifference {
    /**
     * 
     * @type {NamespaceUserset}
     * @memberof NamespaceDifference
     */
    base?: NamespaceUserset;
    /**
     * 
     * @type {NamespaceUserset}
     * @memberof NamespaceDifference
     */
    subtract?: NamespaceUserset;
}
/**
 * 
 * @export
 * @interface NamespaceNamespace
 */
export interface NamespaceNamespace {
    /**
     * 
     * @type {string}
     * @memberof NamespaceNamespace
     */
    name?: string;
    /**
     * 
     * @type {{ [key: string]: NamespaceUserset; }}
     * @memberof NamespaceNamespace
     */
    relations?: { [key: string]: NamespaceUserset; };
}
/**
 * 
 * @export
 * @interface NamespaceNamespaceConfiguration
 */
export interface NamespaceNamespaceConfiguration {
    /**
     * 
     * @type {string}
     * @memberof NamespaceNamespaceConfiguration
     */
    id?: string;
    /**
     * 
     * @type {NamespaceNamespaces}
     * @memberof NamespaceNamespaceConfiguration
     */
    namespaces?: NamespaceNamespaces;
}
/**
 * 
 * @export
 * @interface NamespaceNamespaces
 */
export interface NamespaceNamespaces {
    /**
     * 
     * @type {Array<NamespaceNamespace>}
     * @memberof NamespaceNamespaces
     */
    namespaces?: Array<NamespaceNamespace>;
}
/**
 * 
 * @export
 * @interface NamespaceObjectRelation
 */
export interface NamespaceObjectRelation {
    /**
     * 
     * @type {string}
     * @memberof NamespaceObjectRelation
     */
    object?: string;
    /**
     * 
     * @type {string}
     * @memberof NamespaceObjectRelation
     */
    relation?: string;
}
/**
 * 
 * @export
 * @interface NamespaceTupleToUserset
 */
export interface NamespaceTupleToUserset {
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceTupleToUserset
     */
    tupleset?: NamespaceObjectRelation;
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceTupleToUserset
     */
    computedUserset?: NamespaceObjectRelation;
}
/**
 * 
 * @export
 * @interface NamespaceUserset
 */
export interface NamespaceUserset {
    /**
     * A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.
     * @type {object}
     * @memberof NamespaceUserset
     */
    _this?: object;
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceUserset
     */
    computedUserset?: NamespaceObjectRelation;
    /**
     * 
     * @type {NamespaceTupleToUserset}
     * @memberof NamespaceUserset
     */
    tupleToUserset?: NamespaceTupleToUserset;
    /**
     * 
     * @type {NamespaceUsersets}
     * @memberof NamespaceUserset
     */
    union?: NamespaceUsersets;
    /**
     * 
     * @type {NamespaceUsersets}
     * @memberof NamespaceUserset
     */
    intersection?: NamespaceUsersets;
    /**
     * 
     * @type {NamespaceDifference}
     * @memberof NamespaceUserset
     */
    difference?: NamespaceDifference;
}
/**
 * 
 * @export
 * @interface NamespaceUsersets
 */
export interface NamespaceUsersets {
    /**
     * 
     * @type {Array<NamespaceUserset>}
     * @memberof NamespaceUsersets
     */
    child?: Array<NamespaceUserset>;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    typeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    details?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface SandcastleCheckRequestParams
 */
export interface SandcastleCheckRequestParams {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleCheckRequestParams
     */
    tuple_key?: SandcastleTupleKey;
    /**
     * defaults to false. making it true has performance implications. only use for debugging purposes, etc.
     * @type {boolean}
     * @memberof SandcastleCheckRequestParams
     */
    trace?: boolean;
}
/**
 * 
 * @export
 * @interface SandcastleCheckResponse
 */
export interface SandcastleCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SandcastleCheckResponse
     */
    allowed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SandcastleCheckResponse
     */
    resolution?: string;
}
/**
 * 
 * @export
 * @interface SandcastleExpandRequestParams
 */
export interface SandcastleExpandRequestParams {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleExpandRequestParams
     */
    tuple_key?: SandcastleTupleKey;
}
/**
 * 
 * @export
 * @interface SandcastleExpandResponse
 */
export interface SandcastleExpandResponse {
    /**
     * 
     * @type {SandcastleUsersetTree}
     * @memberof SandcastleExpandResponse
     */
    tree?: SandcastleUsersetTree;
}
/**
 * 
 * @export
 * @interface SandcastleReadAllNamespaceConfigurationsResponse
 */
export interface SandcastleReadAllNamespaceConfigurationsResponse {
    /**
     * 
     * @type {Array<NamespaceNamespaceConfiguration>}
     * @memberof SandcastleReadAllNamespaceConfigurationsResponse
     */
    configurations?: Array<NamespaceNamespaceConfiguration>;
}
/**
 * 
 * @export
 * @interface SandcastleReadNamespaceConfigurationResponse
 */
export interface SandcastleReadNamespaceConfigurationResponse {
    /**
     * 
     * @type {NamespaceNamespaceConfiguration}
     * @memberof SandcastleReadNamespaceConfigurationResponse
     */
    configuration?: NamespaceNamespaceConfiguration;
}
/**
 * 
 * @export
 * @interface SandcastleReadRequestParams
 */
export interface SandcastleReadRequestParams {
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleReadRequestParams
     */
    reads?: SandcastleTupleKeys;
}
/**
 * 
 * @export
 * @interface SandcastleReadResponse
 */
export interface SandcastleReadResponse {
    /**
     * 
     * @type {Array<SandcastleTuple>}
     * @memberof SandcastleReadResponse
     */
    tuples?: Array<SandcastleTuple>;
}
/**
 * 
 * @export
 * @interface SandcastleReadTuplesRequest
 */
export interface SandcastleReadTuplesRequest {
    /**
     * 
     * @type {string}
     * @memberof SandcastleReadTuplesRequest
     */
    storeId?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTuple
 */
export interface SandcastleTuple {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleTuple
     */
    key?: SandcastleTupleKey;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTuple
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTupleKey
 */
export interface SandcastleTupleKey {
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    object?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    relation?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    user?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTupleKeys
 */
export interface SandcastleTupleKeys {
    /**
     * 
     * @type {Array<SandcastleTupleKey>}
     * @memberof SandcastleTupleKeys
     */
    tuple_keys?: Array<SandcastleTupleKey>;
}
/**
 * A UsersetTree contains the result of an Expansion.
 * @export
 * @interface SandcastleUsersetTree
 */
export interface SandcastleUsersetTree {
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTree
     */
    root?: UsersetTreeNode;
}
/**
 * 
 * @export
 * @interface SandcastleUsersetTreeDifference
 */
export interface SandcastleUsersetTreeDifference {
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTreeDifference
     */
    base?: UsersetTreeNode;
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTreeDifference
     */
    subtract?: UsersetTreeNode;
}
/**
 * 
 * @export
 * @interface SandcastleUsersetTreeTupleToUserset
 */
export interface SandcastleUsersetTreeTupleToUserset {
    /**
     * 
     * @type {string}
     * @memberof SandcastleUsersetTreeTupleToUserset
     */
    tupleset?: string;
    /**
     * 
     * @type {Array<UsersetTreeComputed>}
     * @memberof SandcastleUsersetTreeTupleToUserset
     */
    computed?: Array<UsersetTreeComputed>;
}
/**
 * 
 * @export
 * @interface SandcastleWriteNamespaceConfigurationResponse
 */
export interface SandcastleWriteNamespaceConfigurationResponse {
    /**
     * 
     * @type {string}
     * @memberof SandcastleWriteNamespaceConfigurationResponse
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface SandcastleWriteRequestParams
 */
export interface SandcastleWriteRequestParams {
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleWriteRequestParams
     */
    writes?: SandcastleTupleKeys;
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleWriteRequestParams
     */
    deletes?: SandcastleTupleKeys;
    /**
     * 
     * @type {SandcastleTuple}
     * @memberof SandcastleWriteRequestParams
     */
    lock_tuple?: SandcastleTuple;
}
/**
 * 
 * @export
 * @interface SandcastleWriteSettingsRequestParams
 */
export interface SandcastleWriteSettingsRequestParams {
    /**
     * 
     * @type {SettingsEnvironment}
     * @memberof SandcastleWriteSettingsRequestParams
     */
    environment?: SettingsEnvironment;
}
/**
 * 
 * @export
 * @interface SandcastleWriteTokenIssuersRequestParams
 */
export interface SandcastleWriteTokenIssuersRequestParams {
    /**
     * 
     * @type {string}
     * @memberof SandcastleWriteTokenIssuersRequestParams
     */
    issuer_url?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SettingsEnvironment {
    EnvironmentUnspecified = 'ENVIRONMENT_UNSPECIFIED',
    Development = 'DEVELOPMENT',
    Staging = 'STAGING',
    Production = 'PRODUCTION'
}

/**
 * 
 * @export
 * @interface SettingsSettings
 */
export interface SettingsSettings {
    /**
     * 
     * @type {SettingsEnvironment}
     * @memberof SettingsSettings
     */
    environment?: SettingsEnvironment;
    /**
     * 
     * @type {Array<SettingsTokenIssuer>}
     * @memberof SettingsSettings
     */
    token_issuers?: Array<SettingsTokenIssuer>;
}
/**
 * 
 * @export
 * @interface SettingsTokenIssuer
 */
export interface SettingsTokenIssuer {
    /**
     * 
     * @type {string}
     * @memberof SettingsTokenIssuer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SettingsTokenIssuer
     */
    issuer_url?: string;
}
/**
 * 
 * @export
 * @interface UsersetTreeComputed
 */
export interface UsersetTreeComputed {
    /**
     * 
     * @type {string}
     * @memberof UsersetTreeComputed
     */
    userset?: string;
}
/**
 * A leaf node contains either  - a set of users (which may  be individual users, or usersets referencing other  relations - a computed node, which is the result of a computed   userset value in the namespace - a tupleToUserset nodes, containing the result   of expanding a tupleToUserset value in a namespace.
 * @export
 * @interface UsersetTreeLeaf
 */
export interface UsersetTreeLeaf {
    /**
     * 
     * @type {UsersetTreeUsers}
     * @memberof UsersetTreeLeaf
     */
    users?: UsersetTreeUsers;
    /**
     * 
     * @type {UsersetTreeComputed}
     * @memberof UsersetTreeLeaf
     */
    computed?: UsersetTreeComputed;
    /**
     * 
     * @type {SandcastleUsersetTreeTupleToUserset}
     * @memberof UsersetTreeLeaf
     */
    tupleToUserset?: SandcastleUsersetTreeTupleToUserset;
}
/**
 * 
 * @export
 * @interface UsersetTreeNode
 */
export interface UsersetTreeNode {
    /**
     * 
     * @type {string}
     * @memberof UsersetTreeNode
     */
    name?: string;
    /**
     * 
     * @type {UsersetTreeLeaf}
     * @memberof UsersetTreeNode
     */
    leaf?: UsersetTreeLeaf;
    /**
     * 
     * @type {SandcastleUsersetTreeDifference}
     * @memberof UsersetTreeNode
     */
    difference?: SandcastleUsersetTreeDifference;
    /**
     * 
     * @type {UsersetTreeNodes}
     * @memberof UsersetTreeNode
     */
    union?: UsersetTreeNodes;
    /**
     * 
     * @type {UsersetTreeNodes}
     * @memberof UsersetTreeNode
     */
    intersection?: UsersetTreeNodes;
}
/**
 * 
 * @export
 * @interface UsersetTreeNodes
 */
export interface UsersetTreeNodes {
    /**
     * 
     * @type {Array<UsersetTreeNode>}
     * @memberof UsersetTreeNodes
     */
    nodes?: Array<UsersetTreeNode>;
}
/**
 * 
 * @export
 * @interface UsersetTreeUsers
 */
export interface UsersetTreeUsers {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersetTreeUsers
     */
    users?: Array<string>;
}

/**
 * SandcastleApi - axios parameter creator
 * @export
 */
export const SandcastleApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * The check API will return whether the user has a certain relationship with an object in a certain store. Path parameter `storeId` as well as body parameter `object`, `relation` and `user` are all required. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user anne@auth0.com has an owner relationship with object document:2021-budget, a check API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"owner\"     \"user\": \"anne@auth0.com\"   } } ``` Sandcastle\'s response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn\'t.
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check: async (body: SandcastleCheckRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('check', 'body', body)
            const localVarPath = `/{storeId}/check`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTokenIssuer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTokenIssuer', 'id', id)
            const localVarPath = `/{storeId}/settings/token-issuers/{id}`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
                        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The expand API will return all users (including user and userset) that have certain relationship with an object in a certain store. This is different from the `/{store_id}/read` API in that both direct and indirect references are returned. Path parameter `storeId` as well as body parameter `object`, `relation` are all required. The response will return a userset tree whose leafs are the user id and usersets.  Union, intersection and difference operator are located in the intermediate nodes.  ## Example Assume the namesapce configuration for document has the following configuration ```   - name: document     relations:       reader:         anyOf:           - self           - usersRelatedToObjectAs: writer       writer:         self ``` In order to expand all users that have reader relationship with object document:2021-budget, an expand API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   } } ``` Sandcastle\'s response will be a userset tree of the users and computed usersets that have read access to the document. ``` {   \"tree\":{     \"root\":{       \"name\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"bob@auth0.com\"                 ]               }             }           },           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the writer relationship for the `document:2021-budget`.
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expand: async (body: SandcastleExpandRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('expand', 'body', body)
            const localVarPath = `/{storeId}/expand`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read: async (body: SandcastleReadRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('read', 'body', body)
            const localVarPath = `/{storeId}/read`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllNamespaceConfigurations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/{storeId}/namespace-configurations`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNamespaceConfiguration: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readNamespaceConfiguration', 'id', id)
            const localVarPath = `/{storeId}/namespace-configurations/{id}`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
                        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSettings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/{storeId}/settings`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTuples: async (body: SandcastleReadTuplesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('readTuples', 'body', body)
            const localVarPath = `/{storeId}/read-tuples`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        write: async (body: SandcastleWriteRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('write', 'body', body)
            const localVarPath = `/{storeId}/write`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeNamespaceConfiguration: async (body: NamespaceNamespaces, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('writeNamespaceConfiguration', 'body', body)
            const localVarPath = `/{storeId}/namespace-configurations`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleWriteSettingsRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeSettings: async (body: SandcastleWriteSettingsRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('writeSettings', 'body', body)
            const localVarPath = `/{storeId}/settings`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleWriteTokenIssuersRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeTokenIssuer: async (body: SandcastleWriteTokenIssuersRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('writeTokenIssuer', 'body', body)
            const localVarPath = `/{storeId}/settings/token-issuers`
            .replace(`{${"storeId"}}`, encodeURIComponent(String(configuration.storeId)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SandcastleApi - functional programming interface
 * @export
 */
export const SandcastleApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = SandcastleApiAxiosParamCreator(configuration)
    return {
        /**
         * The check API will return whether the user has a certain relationship with an object in a certain store. Path parameter `storeId` as well as body parameter `object`, `relation` and `user` are all required. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user anne@auth0.com has an owner relationship with object document:2021-budget, a check API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"owner\"     \"user\": \"anne@auth0.com\"   } } ``` Sandcastle\'s response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn\'t.
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async check(body: SandcastleCheckRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.check(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTokenIssuer(id: string, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTokenIssuer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * The expand API will return all users (including user and userset) that have certain relationship with an object in a certain store. This is different from the `/{store_id}/read` API in that both direct and indirect references are returned. Path parameter `storeId` as well as body parameter `object`, `relation` are all required. The response will return a userset tree whose leafs are the user id and usersets.  Union, intersection and difference operator are located in the intermediate nodes.  ## Example Assume the namesapce configuration for document has the following configuration ```   - name: document     relations:       reader:         anyOf:           - self           - usersRelatedToObjectAs: writer       writer:         self ``` In order to expand all users that have reader relationship with object document:2021-budget, an expand API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   } } ``` Sandcastle\'s response will be a userset tree of the users and computed usersets that have read access to the document. ``` {   \"tree\":{     \"root\":{       \"name\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"bob@auth0.com\"                 ]               }             }           },           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the writer relationship for the `document:2021-budget`.
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expand(body: SandcastleExpandRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleExpandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expand(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async read(body: SandcastleReadRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.read(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readAllNamespaceConfigurations(options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleReadAllNamespaceConfigurationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readAllNamespaceConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readNamespaceConfiguration(id: string, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleReadNamespaceConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readNamespaceConfiguration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSettings(options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SettingsSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTuples(body: SandcastleReadTuplesRequest, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTuples(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async write(body: SandcastleWriteRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.write(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeNamespaceConfiguration(body: NamespaceNamespaces, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SandcastleWriteNamespaceConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeNamespaceConfiguration(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleWriteSettingsRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeSettings(body: SandcastleWriteSettingsRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SettingsSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeSettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleWriteTokenIssuersRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async writeTokenIssuer(body: SandcastleWriteTokenIssuersRequestParams, options?: any): Promise<(axios?: AxiosInstance) => PromiseResult<SettingsTokenIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.writeTokenIssuer(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * SandcastleApi - factory interface
 * @export
 */
export const SandcastleApiFactory = function (configuration: Configuration, axios?: AxiosInstance) {
    const localVarFp = SandcastleApiFp(configuration)
    return {
        /**
         * The check API will return whether the user has a certain relationship with an object in a certain store. Path parameter `storeId` as well as body parameter `object`, `relation` and `user` are all required. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user anne@auth0.com has an owner relationship with object document:2021-budget, a check API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"owner\"     \"user\": \"anne@auth0.com\"   } } ``` Sandcastle\'s response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn\'t.
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check(body: SandcastleCheckRequestParams, options?: any): PromiseResult<SandcastleCheckResponse> {
            return localVarFp.check(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTokenIssuer(id: string, options?: any): PromiseResult<object> {
            return localVarFp.deleteTokenIssuer(id, options).then((request) => request(axios));
        },
        /**
         * The expand API will return all users (including user and userset) that have certain relationship with an object in a certain store. This is different from the `/{store_id}/read` API in that both direct and indirect references are returned. Path parameter `storeId` as well as body parameter `object`, `relation` are all required. The response will return a userset tree whose leafs are the user id and usersets.  Union, intersection and difference operator are located in the intermediate nodes.  ## Example Assume the namesapce configuration for document has the following configuration ```   - name: document     relations:       reader:         anyOf:           - self           - usersRelatedToObjectAs: writer       writer:         self ``` In order to expand all users that have reader relationship with object document:2021-budget, an expand API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   } } ``` Sandcastle\'s response will be a userset tree of the users and computed usersets that have read access to the document. ``` {   \"tree\":{     \"root\":{       \"name\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"bob@auth0.com\"                 ]               }             }           },           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the writer relationship for the `document:2021-budget`.
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expand(body: SandcastleExpandRequestParams, options?: any): PromiseResult<SandcastleExpandResponse> {
            return localVarFp.expand(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        read(body: SandcastleReadRequestParams, options?: any): PromiseResult<SandcastleReadResponse> {
            return localVarFp.read(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllNamespaceConfigurations(options?: any): PromiseResult<SandcastleReadAllNamespaceConfigurationsResponse> {
            return localVarFp.readAllNamespaceConfigurations(options).then((request) => request(axios));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readNamespaceConfiguration(id: string, options?: any): PromiseResult<SandcastleReadNamespaceConfigurationResponse> {
            return localVarFp.readNamespaceConfiguration(id, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSettings(options?: any): PromiseResult<SettingsSettings> {
            return localVarFp.readSettings(options).then((request) => request(axios));
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTuples(body: SandcastleReadTuplesRequest, options?: any): PromiseResult<SandcastleReadResponse> {
            return localVarFp.readTuples(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        write(body: SandcastleWriteRequestParams, options?: any): PromiseResult<object> {
            return localVarFp.write(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeNamespaceConfiguration(body: NamespaceNamespaces, options?: any): PromiseResult<SandcastleWriteNamespaceConfigurationResponse> {
            return localVarFp.writeNamespaceConfiguration(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleWriteSettingsRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeSettings(body: SandcastleWriteSettingsRequestParams, options?: any): PromiseResult<SettingsSettings> {
            return localVarFp.writeSettings(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleWriteTokenIssuersRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        writeTokenIssuer(body: SandcastleWriteTokenIssuersRequestParams, options?: any): PromiseResult<SettingsTokenIssuer> {
            return localVarFp.writeTokenIssuer(body, options).then((request) => request(axios));
        },
    };
};

/**
 * SandcastleApi - object-oriented interface
 * @export
 * @class SandcastleApi
 * @extends {BaseAPI}
 */
export class SandcastleApi extends BaseAPI {
    /**
     * The check API will return whether the user has a certain relationship with an object in a certain store. Path parameter `storeId` as well as body parameter `object`, `relation` and `user` are all required. The response will return whether the relationship exists in the field `allowed`.  ## Example In order to check if user anne@auth0.com has an owner relationship with object document:2021-budget, a check API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"owner\"     \"user\": \"anne@auth0.com\"   } } ``` Sandcastle\'s response will include `{ \"allowed\": true }` if there is a relationship and `{ \"allowed\": false }` if there isn\'t.
     * @param {SandcastleCheckRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public check(body: SandcastleCheckRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).check(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public deleteTokenIssuer(id: string, options?: any) {
        return SandcastleApiFp(this.configuration).deleteTokenIssuer(id, options).then((request) => request(this.axios));
    }

    /**
     * The expand API will return all users (including user and userset) that have certain relationship with an object in a certain store. This is different from the `/{store_id}/read` API in that both direct and indirect references are returned. Path parameter `storeId` as well as body parameter `object`, `relation` are all required. The response will return a userset tree whose leafs are the user id and usersets.  Union, intersection and difference operator are located in the intermediate nodes.  ## Example Assume the namesapce configuration for document has the following configuration ```   - name: document     relations:       reader:         anyOf:           - self           - usersRelatedToObjectAs: writer       writer:         self ``` In order to expand all users that have reader relationship with object document:2021-budget, an expand API call should be fired with the following body ``` {   \"tuple_key\": {     \"object\": \"document:2021-budget\",     \"relation\": \"reader\"   } } ``` Sandcastle\'s response will be a userset tree of the users and computed usersets that have read access to the document. ``` {   \"tree\":{     \"root\":{       \"name\":\"document:2021-budget#reader\",       \"union\":{         \"nodes\":[           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"users\":{                 \"users\":[                   \"bob@auth0.com\"                 ]               }             }           },           {             \"name\":\"document:2021-budget#reader\",             \"leaf\":{               \"computed\":{                 \"userset\":\"document:2021-budget#writer\"               }             }           }         ]       }     }   } } ``` The caller can then call expand API for the writer relationship for the `document:2021-budget`.
     * @param {SandcastleExpandRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public expand(body: SandcastleExpandRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).expand(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleReadRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public read(body: SandcastleReadRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).read(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public readAllNamespaceConfigurations(options?: any) {
        return SandcastleApiFp(this.configuration).readAllNamespaceConfigurations(options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public readNamespaceConfiguration(id: string, options?: any) {
        return SandcastleApiFp(this.configuration).readNamespaceConfiguration(id, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public readSettings(options?: any) {
        return SandcastleApiFp(this.configuration).readSettings(options).then((request) => request(this.axios));
    }

    /**
     * 
     * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
     * @param {SandcastleReadTuplesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public readTuples(body: SandcastleReadTuplesRequest, options?: any) {
        return SandcastleApiFp(this.configuration).readTuples(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleWriteRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public write(body: SandcastleWriteRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).write(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {NamespaceNamespaces} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public writeNamespaceConfiguration(body: NamespaceNamespaces, options?: any) {
        return SandcastleApiFp(this.configuration).writeNamespaceConfiguration(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleWriteSettingsRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public writeSettings(body: SandcastleWriteSettingsRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).writeSettings(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleWriteTokenIssuersRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public writeTokenIssuer(body: SandcastleWriteTokenIssuersRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).writeTokenIssuer(body, options).then((request) => request(this.axios));
    }
}


