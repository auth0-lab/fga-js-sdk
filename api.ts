/* tslint:disable */
/* eslint-disable */
/**
 * Sandcastle
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * Contact: https://discord.gg/8naAwJfWN6
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

import { COLLECTION_FORMATS, BaseAPI } from './base';
import { DUMMY_BASE_URL, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, RequestArgs } from './common';
import { assertParamExists, Configuration, RequiredError } from './configuration';

/**
 * 
 * @export
 * @interface NamespaceDifference
 */
export interface NamespaceDifference {
    /**
     * 
     * @type {NamespaceUserset}
     * @memberof NamespaceDifference
     */
    base?: NamespaceUserset;
    /**
     * 
     * @type {NamespaceUserset}
     * @memberof NamespaceDifference
     */
    subtract?: NamespaceUserset;
}
/**
 * 
 * @export
 * @interface NamespaceNamespace
 */
export interface NamespaceNamespace {
    /**
     * 
     * @type {string}
     * @memberof NamespaceNamespace
     */
    name?: string;
    /**
     * 
     * @type {{ [key: string]: NamespaceUserset; }}
     * @memberof NamespaceNamespace
     */
    relations?: { [key: string]: NamespaceUserset; };
}
/**
 * 
 * @export
 * @interface NamespaceNamespaceConfiguration
 */
export interface NamespaceNamespaceConfiguration {
    /**
     * 
     * @type {string}
     * @memberof NamespaceNamespaceConfiguration
     */
    id?: string;
    /**
     * 
     * @type {NamespaceNamespaces}
     * @memberof NamespaceNamespaceConfiguration
     */
    namespaces?: NamespaceNamespaces;
}
/**
 * 
 * @export
 * @interface NamespaceNamespaces
 */
export interface NamespaceNamespaces {
    /**
     * 
     * @type {Array<NamespaceNamespace>}
     * @memberof NamespaceNamespaces
     */
    namespaces?: Array<NamespaceNamespace>;
}
/**
 * 
 * @export
 * @interface NamespaceObjectRelation
 */
export interface NamespaceObjectRelation {
    /**
     * 
     * @type {string}
     * @memberof NamespaceObjectRelation
     */
    object?: string;
    /**
     * 
     * @type {string}
     * @memberof NamespaceObjectRelation
     */
    relation?: string;
}
/**
 * 
 * @export
 * @interface NamespaceTupleToUserset
 */
export interface NamespaceTupleToUserset {
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceTupleToUserset
     */
    tupleset?: NamespaceObjectRelation;
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceTupleToUserset
     */
    computedUserset?: NamespaceObjectRelation;
}
/**
 * 
 * @export
 * @interface NamespaceUserset
 */
export interface NamespaceUserset {
    /**
     * A DirectUserset is a sentinel message for referencing the direct members specified by an object/relation mapping.
     * @type {object}
     * @memberof NamespaceUserset
     */
    _this?: object;
    /**
     * 
     * @type {NamespaceObjectRelation}
     * @memberof NamespaceUserset
     */
    computedUserset?: NamespaceObjectRelation;
    /**
     * 
     * @type {NamespaceTupleToUserset}
     * @memberof NamespaceUserset
     */
    tupleToUserset?: NamespaceTupleToUserset;
    /**
     * 
     * @type {NamespaceUsersets}
     * @memberof NamespaceUserset
     */
    union?: NamespaceUsersets;
    /**
     * 
     * @type {NamespaceUsersets}
     * @memberof NamespaceUserset
     */
    intersection?: NamespaceUsersets;
    /**
     * 
     * @type {NamespaceDifference}
     * @memberof NamespaceUserset
     */
    difference?: NamespaceDifference;
}
/**
 * 
 * @export
 * @interface NamespaceUsersets
 */
export interface NamespaceUsersets {
    /**
     * 
     * @type {Array<NamespaceUserset>}
     * @memberof NamespaceUsersets
     */
    child?: Array<NamespaceUserset>;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    typeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    details?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface SandcastleCheckRequestParams
 */
export interface SandcastleCheckRequestParams {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleCheckRequestParams
     */
    tupleKey?: SandcastleTupleKey;
    /**
     * defaults to false. making it true has performance implications. only use for debugging purposes, etc.
     * @type {boolean}
     * @memberof SandcastleCheckRequestParams
     */
    trace?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SandcastleCheckRequestParams
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleCheckResponse
 */
export interface SandcastleCheckResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SandcastleCheckResponse
     */
    allowed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SandcastleCheckResponse
     */
    resolution?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleCheckResponse
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleExpandRequestParams
 */
export interface SandcastleExpandRequestParams {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleExpandRequestParams
     */
    tupleKey?: SandcastleTupleKey;
    /**
     * 
     * @type {string}
     * @memberof SandcastleExpandRequestParams
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleExpandResponse
 */
export interface SandcastleExpandResponse {
    /**
     * 
     * @type {SandcastleUsersetTree}
     * @memberof SandcastleExpandResponse
     */
    tree?: SandcastleUsersetTree;
}
/**
 * 
 * @export
 * @interface SandcastleReadAllNamespaceConfigurationsResponse
 */
export interface SandcastleReadAllNamespaceConfigurationsResponse {
    /**
     * 
     * @type {Array<NamespaceNamespaceConfiguration>}
     * @memberof SandcastleReadAllNamespaceConfigurationsResponse
     */
    configurations?: Array<NamespaceNamespaceConfiguration>;
}
/**
 * 
 * @export
 * @interface SandcastleReadNamespaceConfigurationResponse
 */
export interface SandcastleReadNamespaceConfigurationResponse {
    /**
     * 
     * @type {NamespaceNamespaceConfiguration}
     * @memberof SandcastleReadNamespaceConfigurationResponse
     */
    configuration?: NamespaceNamespaceConfiguration;
}
/**
 * 
 * @export
 * @interface SandcastleReadRequestParams
 */
export interface SandcastleReadRequestParams {
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleReadRequestParams
     */
    reads?: SandcastleTupleKeys;
    /**
     * 
     * @type {string}
     * @memberof SandcastleReadRequestParams
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleReadResponse
 */
export interface SandcastleReadResponse {
    /**
     * 
     * @type {Array<SandcastleTuple>}
     * @memberof SandcastleReadResponse
     */
    tuples?: Array<SandcastleTuple>;
    /**
     * 
     * @type {string}
     * @memberof SandcastleReadResponse
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleReadTuplesRequest
 */
export interface SandcastleReadTuplesRequest {
    /**
     * 
     * @type {string}
     * @memberof SandcastleReadTuplesRequest
     */
    tenant?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTuple
 */
export interface SandcastleTuple {
    /**
     * 
     * @type {SandcastleTupleKey}
     * @memberof SandcastleTuple
     */
    key?: SandcastleTupleKey;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTuple
     */
    timestamp?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTupleKey
 */
export interface SandcastleTupleKey {
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    object?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    relation?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleTupleKey
     */
    user?: string;
}
/**
 * 
 * @export
 * @interface SandcastleTupleKeys
 */
export interface SandcastleTupleKeys {
    /**
     * 
     * @type {Array<SandcastleTupleKey>}
     * @memberof SandcastleTupleKeys
     */
    tupleKeys?: Array<SandcastleTupleKey>;
}
/**
 * A UsersetTree contains the result of an Expansion.
 * @export
 * @interface SandcastleUsersetTree
 */
export interface SandcastleUsersetTree {
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTree
     */
    root?: UsersetTreeNode;
}
/**
 * 
 * @export
 * @interface SandcastleUsersetTreeDifference
 */
export interface SandcastleUsersetTreeDifference {
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTreeDifference
     */
    base?: UsersetTreeNode;
    /**
     * 
     * @type {UsersetTreeNode}
     * @memberof SandcastleUsersetTreeDifference
     */
    subtract?: UsersetTreeNode;
}
/**
 * 
 * @export
 * @interface SandcastleUsersetTreeTupleToUserset
 */
export interface SandcastleUsersetTreeTupleToUserset {
    /**
     * 
     * @type {string}
     * @memberof SandcastleUsersetTreeTupleToUserset
     */
    tupleset?: string;
    /**
     * 
     * @type {Array<UsersetTreeComputed>}
     * @memberof SandcastleUsersetTreeTupleToUserset
     */
    computed?: Array<UsersetTreeComputed>;
}
/**
 * 
 * @export
 * @interface SandcastleWriteNamespaceConfigurationResponse
 */
export interface SandcastleWriteNamespaceConfigurationResponse {
    /**
     * 
     * @type {string}
     * @memberof SandcastleWriteNamespaceConfigurationResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SandcastleWriteNamespaceConfigurationResponse
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface SandcastleWriteRequestParams
 */
export interface SandcastleWriteRequestParams {
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleWriteRequestParams
     */
    writes?: SandcastleTupleKeys;
    /**
     * 
     * @type {SandcastleTupleKeys}
     * @memberof SandcastleWriteRequestParams
     */
    deletes?: SandcastleTupleKeys;
    /**
     * 
     * @type {SandcastleTuple}
     * @memberof SandcastleWriteRequestParams
     */
    lockTuple?: SandcastleTuple;
}
/**
 * 
 * @export
 * @interface SandcastleWriteResponse
 */
export interface SandcastleWriteResponse {
    /**
     * 
     * @type {string}
     * @memberof SandcastleWriteResponse
     */
    zookie?: string;
}
/**
 * 
 * @export
 * @interface UsersetTreeComputed
 */
export interface UsersetTreeComputed {
    /**
     * 
     * @type {string}
     * @memberof UsersetTreeComputed
     */
    userset?: string;
}
/**
 * A leaf node contains either  - a set of users (which may  be individual users, or usersets referencing other  relations - a computed node, which is the result of a computed   userset value in the namespace - a tupleToUserset nodes, containing the result   of expanding a tupleToUserset value in a namespace.
 * @export
 * @interface UsersetTreeLeaf
 */
export interface UsersetTreeLeaf {
    /**
     * 
     * @type {UsersetTreeUsers}
     * @memberof UsersetTreeLeaf
     */
    users?: UsersetTreeUsers;
    /**
     * 
     * @type {UsersetTreeComputed}
     * @memberof UsersetTreeLeaf
     */
    computed?: UsersetTreeComputed;
    /**
     * 
     * @type {SandcastleUsersetTreeTupleToUserset}
     * @memberof UsersetTreeLeaf
     */
    tupleToUserset?: SandcastleUsersetTreeTupleToUserset;
}
/**
 * 
 * @export
 * @interface UsersetTreeNode
 */
export interface UsersetTreeNode {
    /**
     * 
     * @type {string}
     * @memberof UsersetTreeNode
     */
    name?: string;
    /**
     * 
     * @type {UsersetTreeLeaf}
     * @memberof UsersetTreeNode
     */
    leaf?: UsersetTreeLeaf;
    /**
     * 
     * @type {SandcastleUsersetTreeDifference}
     * @memberof UsersetTreeNode
     */
    difference?: SandcastleUsersetTreeDifference;
    /**
     * 
     * @type {UsersetTreeNodes}
     * @memberof UsersetTreeNode
     */
    union?: UsersetTreeNodes;
    /**
     * 
     * @type {UsersetTreeNodes}
     * @memberof UsersetTreeNode
     */
    intersection?: UsersetTreeNodes;
}
/**
 * 
 * @export
 * @interface UsersetTreeNodes
 */
export interface UsersetTreeNodes {
    /**
     * 
     * @type {Array<UsersetTreeNode>}
     * @memberof UsersetTreeNodes
     */
    nodes?: Array<UsersetTreeNode>;
}
/**
 * 
 * @export
 * @interface UsersetTreeUsers
 */
export interface UsersetTreeUsers {
    /**
     * 
     * @type {Array<string>}
     * @memberof UsersetTreeUsers
     */
    users?: Array<string>;
}

/**
 * SandcastleApi - axios parameter creator
 * @export
 */
export const SandcastleApiAxiosParamCreator = function (configuration: Configuration) {
    return {
        /**
         * 
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleCheck: async (body: SandcastleCheckRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleCheck', 'body', body)
            const localVarPath = `/{tenant}/v1/check`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleExpand: async (body: SandcastleExpandRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleExpand', 'body', body)
            const localVarPath = `/{tenant}/v1/expand`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleRead: async (body: SandcastleReadRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleRead', 'body', body)
            const localVarPath = `/{tenant}/v1/read`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadAllNamespaceConfigurations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/{tenant}/v1/namespace-configurations`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadNamespaceConfiguration: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sandcastleReadNamespaceConfiguration', 'id', id)
            const localVarPath = `/{tenant}/v1/namespace-configurations/{id}`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
                        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadTuples: async (body: SandcastleReadTuplesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleReadTuples', 'body', body)
            const localVarPath = `/{tenant}/v1/read-tuples`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleWrite: async (body: SandcastleWriteRequestParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleWrite', 'body', body)
            const localVarPath = `/{tenant}/v1/write`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleWriteNamespaceConfiguration: async (body: NamespaceNamespaces, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sandcastleWriteNamespaceConfiguration', 'body', body)
            const localVarPath = `/{tenant}/v1/namespace-configurations`
            .replace(`{${"tenant"}}`, encodeURIComponent(String(configuration.tenant)))
            ;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ClientCredentials required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SandcastleApi - functional programming interface
 * @export
 */
export const SandcastleApiFp = function(configuration: Configuration) {
    const localVarAxiosParamCreator = SandcastleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleCheck(body: SandcastleCheckRequestParams, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleCheck(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleExpand(body: SandcastleExpandRequestParams, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleExpandResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleExpand(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleRead(body: SandcastleReadRequestParams, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleRead(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleReadAllNamespaceConfigurations(options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleReadAllNamespaceConfigurationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleReadAllNamespaceConfigurations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleReadNamespaceConfiguration(id: string, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleReadNamespaceConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleReadNamespaceConfiguration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleReadTuples(body: SandcastleReadTuplesRequest, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleReadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleReadTuples(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleWrite(body: SandcastleWriteRequestParams, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleWriteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleWrite(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandcastleWriteNamespaceConfiguration(body: NamespaceNamespaces, options?: any): Promise<(axios?: AxiosInstance) => AxiosPromise<SandcastleWriteNamespaceConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandcastleWriteNamespaceConfiguration(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, configuration);
        },
    }
};

/**
 * SandcastleApi - factory interface
 * @export
 */
export const SandcastleApiFactory = function (configuration: Configuration, axios?: AxiosInstance) {
    const localVarFp = SandcastleApiFp(configuration)
    return {
        /**
         * 
         * @param {SandcastleCheckRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleCheck(body: SandcastleCheckRequestParams, options?: any): AxiosPromise<SandcastleCheckResponse> {
            return localVarFp.sandcastleCheck(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleExpandRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleExpand(body: SandcastleExpandRequestParams, options?: any): AxiosPromise<SandcastleExpandResponse> {
            return localVarFp.sandcastleExpand(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleReadRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleRead(body: SandcastleReadRequestParams, options?: any): AxiosPromise<SandcastleReadResponse> {
            return localVarFp.sandcastleRead(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadAllNamespaceConfigurations(options?: any): AxiosPromise<SandcastleReadAllNamespaceConfigurationsResponse> {
            return localVarFp.sandcastleReadAllNamespaceConfigurations(options).then((request) => request(axios));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadNamespaceConfiguration(id: string, options?: any): AxiosPromise<SandcastleReadNamespaceConfigurationResponse> {
            return localVarFp.sandcastleReadNamespaceConfiguration(id, options).then((request) => request(axios));
        },
        /**
         * 
         * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
         * @param {SandcastleReadTuplesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleReadTuples(body: SandcastleReadTuplesRequest, options?: any): AxiosPromise<SandcastleReadResponse> {
            return localVarFp.sandcastleReadTuples(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {SandcastleWriteRequestParams} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleWrite(body: SandcastleWriteRequestParams, options?: any): AxiosPromise<SandcastleWriteResponse> {
            return localVarFp.sandcastleWrite(body, options).then((request) => request(axios));
        },
        /**
         * 
         * @param {NamespaceNamespaces} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandcastleWriteNamespaceConfiguration(body: NamespaceNamespaces, options?: any): AxiosPromise<SandcastleWriteNamespaceConfigurationResponse> {
            return localVarFp.sandcastleWriteNamespaceConfiguration(body, options).then((request) => request(axios));
        },
    };
};

/**
 * SandcastleApi - object-oriented interface
 * @export
 * @class SandcastleApi
 * @extends {BaseAPI}
 */
export class SandcastleApi extends BaseAPI {
    /**
     * 
     * @param {SandcastleCheckRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleCheck(body: SandcastleCheckRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleCheck(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleExpandRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleExpand(body: SandcastleExpandRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleExpand(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleReadRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleRead(body: SandcastleReadRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleRead(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleReadAllNamespaceConfigurations(options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleReadAllNamespaceConfigurations(options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleReadNamespaceConfiguration(id: string, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleReadNamespaceConfiguration(id, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @summary ReadTuples should only be used for the playground. do not enable it for prod deployments
     * @param {SandcastleReadTuplesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleReadTuples(body: SandcastleReadTuplesRequest, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleReadTuples(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {SandcastleWriteRequestParams} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleWrite(body: SandcastleWriteRequestParams, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleWrite(body, options).then((request) => request(this.axios));
    }

    /**
     * 
     * @param {NamespaceNamespaces} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandcastleApi
     */
    public sandcastleWriteNamespaceConfiguration(body: NamespaceNamespaces, options?: any) {
        return SandcastleApiFp(this.configuration).sandcastleWriteNamespaceConfiguration(body, options).then((request) => request(this.axios));
    }
}


