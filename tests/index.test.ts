/**
 * JavaScript and Node.js SDK for Auth0 Fine Grained Authorization (FGA)
 *
 * API version: 0.1
 * Website: <https://fga.dev>
 * Documentation: <https://docs.fga.dev>
 * Support: <https://discord.gg/8naAwJfWN6>
 * License: [MIT](https://github.com/auth0-lab/fga-js-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by [OpenAPI Generator](https://openapi-generator.tech). DO NOT EDIT.
 */

import * as nock from "nock";
import { CallResult } from "@openfga/sdk/dist/common";
import { ClientCredentialsConfig } from "@openfga/sdk/dist/credentials";
import {
  FgaApiInternalError,
  FgaApiNotFoundError,
  FgaApiRateLimitExceededError,
  FgaApiValidationError,
  FgaApiAuthenticationError,
  CheckResponse,
  ErrorCode,
} from "@openfga/sdk";

import { Auth0FgaApi, Configuration, GetDefaultRetryParams } from "../";
import { getNocks } from "./helpers";

nock.disableNetConnect();

const AUTH0_FGA_ENVIRONMENT = "playground";
const AUTH0_FGA_STORE_ID = "01HP11SZ40J32DR7P3VVNBF2BV";
const AUTH0_FGA_CLIENT_ID = "some-random-id";
const AUTH0_FGA_CLIENT_SECRET = "this-is-very-secret";

const baseConfig = {
  storeId: AUTH0_FGA_STORE_ID,
  environment: AUTH0_FGA_ENVIRONMENT,
  clientId: AUTH0_FGA_CLIENT_ID,
  clientSecret: AUTH0_FGA_CLIENT_SECRET,
};

const defaultConfiguration = new Configuration(baseConfig);
const AUTH0_FGA_API_TOKEN_ISSUER = (defaultConfiguration.credentials as { config: ClientCredentialsConfig }).config
  .apiTokenIssuer;

const nocks = getNocks(nock);

describe("Auth0Fga SDK", function () {
  describe("Environment Configurations", () => {
    it("should be able to parse the environment configurations", () => {
      expect(() => Configuration.environmentConfigurations).not.toThrowError();
    });

    it("should be able to parse the environment configurations", () => {
      const config = Configuration.getEnvironmentConfiguration("playground");
      expect(config).toMatchObject({
        apiScheme: "https",
        apiHost: "api.playground.fga.dev",
      });
    });
  });

  describe("initializing the sdk", () => {
    it("should require storeId in configuration", () => {
      expect(() => new Auth0FgaApi({ ...baseConfig, storeId: undefined! })).toThrow();
    });

    it("should allow not passing in an environment in configuration", () => {
      try {
        new Auth0FgaApi({ ...baseConfig, environment: undefined! });
      } catch (err) {
        console.error(err);
      }

      expect(() => new Auth0FgaApi({ ...baseConfig, environment: undefined! })).not.toThrow();
    });

    it("should require a valid environment in configuration", () => {
      expect(
        () =>
          new Auth0FgaApi({
            ...baseConfig,
            environment: "non_existent_environment"!,
          }),
      ).toThrowError();
    });

    it("should not require clientId or clientSecret in configuration in environments that don't require it", () => {
      expect(
        () =>
          new Auth0FgaApi({
            storeId: AUTH0_FGA_STORE_ID,
            environment: "playground",
            clientId: undefined!,
            clientSecret: undefined!,
          }),
      ).not.toThrowError();
    });

    it("should require clientId or clientSecret in configuration in environments that require it", () => {
      expect(
        () =>
          new Auth0FgaApi({
            storeId: AUTH0_FGA_STORE_ID,
            environment: "staging",
            clientId: undefined!,
            clientSecret: undefined!,
          }),
      ).toThrowError();
    });

    it("should issue a network call to get the token at the first request if client id is provided", async () => {
      const scope = nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);
      nocks.readAuthorizationModels(baseConfig.storeId);

      const auth0FgaApi = new Auth0FgaApi(baseConfig);
      expect(scope.isDone()).toBe(false);

      await auth0FgaApi.readAuthorizationModels();

      expect(scope.isDone()).toBe(true);

      nock.cleanAll();
    });

    it("should cache the bearer token and not issue a network call to get the token at the second request", async () => {
      let scope = nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);
      nocks.readAuthorizationModels(baseConfig.storeId!);

      const auth0FgaApi = new Auth0FgaApi(baseConfig);
      expect(scope.isDone()).toBe(false);

      await auth0FgaApi.readAuthorizationModels();

      expect(scope.isDone()).toBe(true);

      nock.cleanAll();
      scope = nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);
      nocks.readAuthorizationModels(baseConfig.storeId!);
      expect(scope.isDone()).toBe(false);

      await auth0FgaApi.readAuthorizationModels();

      expect(scope.isDone()).toBe(false);

      nock.cleanAll();
    });

    it("should not issue a network call to get the token at the first request if the clientId is not provided", async () => {
      const scope = nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);
      nocks.readAuthorizationModels(baseConfig.storeId);

      const auth0FgaApi = new Auth0FgaApi({
        ...baseConfig,
        clientId: undefined!,
        clientSecret: undefined!,
      });
      expect(scope.isDone()).toBe(false);

      await auth0FgaApi.readAuthorizationModels();

      expect(scope.isDone()).toBe(false);

      nock.cleanAll();
    });

    it("should allow passing in a configuration instance", async () => {
      const configuration = new Configuration(baseConfig);
      expect(() => new Auth0FgaApi(configuration)).not.toThrowError();
    });
  });

  describe("error handling", () => {
    let auth0FgaApi: Auth0FgaApi;
    const { storeId } = baseConfig;
    const basePath = defaultConfiguration.getBasePath();
    const requestId = "1F2A3B";

    beforeAll(() => {
      auth0FgaApi = new Auth0FgaApi({ ...baseConfig });
    });

    describe("400 level error should result in FgaApiValidationError", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .defaultReplyHeaders({
            "Fga-Request-Id": requestId,
            "Content-Type": "application/json",
          })
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .reply(400, {
            code: "validation_error",
            message: "nock error",
          });
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should throw FgaApiValidationError", async () => {
        await expect(auth0FgaApi.check({ tuple_key: tupleKey })).rejects.toThrow(FgaApiValidationError);
      });

      it("FgaApiValidationError should have correct fields", async () => {
        try {
          await auth0FgaApi.check({ tuple_key: tupleKey });
        } catch (err) {
          expect(err).toBeInstanceOf(FgaApiValidationError);
          if (err instanceof FgaApiValidationError) {
            expect(err.apiErrorCode).toBe(ErrorCode.ValidationError);
            expect(err.storeId).toBe(storeId);
            expect(err.endpointCategory).toBe("check");
            expect(err.requestId).toBe(requestId);
          }
        }
      });
    });

    describe("429 level error should result in FgaApiRateLimitExceededError", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        const updateBaseConfig = {
          ...baseConfig,
          retryParams: GetDefaultRetryParams(2, 10),
        };
        auth0FgaApi = new Auth0FgaApi({ ...updateBaseConfig });
        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .times(3)
          .reply(429, {
            code: "rate_limit_exceeded",
            message: "nock error",
          });
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should throw FgaApiRateLimitExceededError", async () => {
        await expect(auth0FgaApi.check({ tuple_key: tupleKey }, {})).rejects.toThrow(FgaApiRateLimitExceededError);
      });
    });

    describe("429 with retry in config and retry is successful", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        const updateBaseConfig = {
          ...baseConfig,
          retryParams: GetDefaultRetryParams(2, 10),
        };
        auth0FgaApi = new Auth0FgaApi({ ...updateBaseConfig });

        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .times(1)
          .reply(429, {
            code: "rate_limit_exceeded",
            message: "nock error",
          });

        nocks.check(baseConfig.storeId!, tupleKey);
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should return allowed", async () => {
        const result = await auth0FgaApi.check({ tuple_key: tupleKey }, {});

        expect(result.allowed).toBe(true);
      });
    });

    describe("429 with retry in call and retry is successful", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .times(1)
          .reply(429, {
            code: "rate_limit_exceeded",
            message: "nock error",
          });

        nocks.check(baseConfig.storeId!, tupleKey);
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should return allowed", async () => {
        const result = await auth0FgaApi.check({ tuple_key: tupleKey }, { retryParams: GetDefaultRetryParams(2, 10) });

        expect(result.allowed).toBe(true);
      });
    });

    describe("500 level error should result in FgaApiInternalError", () => {
      it("should throw FgaApiInternalError", async () => {
        const tupleKey = {
          user: "user:xyz",
          relation: "can_view",
          object: "foobar:x",
        };

        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .reply(500, {
            code: "internal_error",
            message: "nock error",
          });

        await expect(auth0FgaApi.check({ tuple_key: tupleKey })).rejects.toThrow(FgaApiInternalError);

        nock.cleanAll();
      });
    });

    describe("404 level error should result in FgaApiNotFoundError", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER, "test-token");

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .reply(404, {
            code: "undefined_endpoint",
            message: "nock error",
          });
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should throw FgaApiNotFoundError", async () => {
        await expect(auth0FgaApi.check({ tuple_key: tupleKey })).rejects.toThrow(FgaApiNotFoundError);
      });
    });

    describe("401 during authentication should result in FgaApiAuthenticationError", () => {
      const tupleKey = {
        user: "user:xyz",
        relation: "can_view",
        object: "foobar:x",
      };

      beforeEach(async () => {
        nock(`https://${AUTH0_FGA_API_TOKEN_ISSUER}`).post("/oauth/token").reply(401);

        nock(basePath)
          .post(
            `/stores/${storeId}/check`,
            {
              tuple_key: tupleKey,
            },
            expect.objectContaining({ Authorization: "Bearer test-token" }),
          )
          .reply(500, {
            code: "invalid_claims",
            message: "nock error",
          });
      });

      afterEach(() => {
        nock.cleanAll();
      });

      it("should throw FgaApiAuthenticationError", async () => {
        auth0FgaApi = new Auth0FgaApi({ ...baseConfig });
        await expect(auth0FgaApi.check({ tuple_key: tupleKey })).rejects.toThrow(FgaApiAuthenticationError);
      });
    });
  });

  describe("happy path of CHECK", () => {
    let result: CallResult<CheckResponse>;
    let auth0FgaApi: Auth0FgaApi;

    beforeAll(async () => {
      auth0FgaApi = new Auth0FgaApi({ ...baseConfig });
      nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);

      const tupleKey = {
        user: "user:xyz",
        relation: "abc",
        object: "foobar:x",
      };
      const scope = nocks.check(baseConfig.storeId!, tupleKey);
      expect(scope.isDone()).toBe(false);

      result = await auth0FgaApi.check({ tuple_key: tupleKey });
      expect(scope.isDone()).toBe(true);

      nock.cleanAll();
    });

    it("should return allowed", () => {
      expect(result.allowed).toBe(true);
    });

    it("should return the proper $response object", () => {
      expect(result).toHaveProperty("$response");
      expect(result.$response.status).toBe(200);
      expect(Object.prototype.propertyIsEnumerable.call(result, "$response")).toBe(false);
    });
  });

  describe("using the sdk", () => {
    let auth0FgaApi: Auth0FgaApi;

    beforeAll(() => {
      auth0FgaApi = new Auth0FgaApi({ ...baseConfig });
    });

    beforeEach(() => {
      nocks.tokenExchange(AUTH0_FGA_API_TOKEN_ISSUER);
    });

    afterEach(() => {
      nock.cleanAll();
    });

    describe("check", () => {
      it("should properly pass the request and return an allowed API response", async () => {
        const tuple = {
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "admin",
          object: "workspace:1",
        };
        const scope = nocks.check(baseConfig.storeId!, tuple);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.check({ tuple_key: tuple });

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({ allowed: expect.any(Boolean) });
      });
    });

    describe("write: write tuples", () => {
      it("should properly pass the errors that the Auth0 Fine Grained Authorization (FGA) API returns", async () => {
        const tuple = {
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "admin",
          object: "workspace:1",
        };
        const scope = nocks.write(baseConfig.storeId!, defaultConfiguration.getBasePath(), tuple);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.write({
          writes: { tuple_keys: [tuple] },
        });

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({});
      });
    });

    describe("write: delete tuples", () => {
      it("should properly pass the errors that the Auth0 Fine Grained Authorization (FGA) API returns", async () => {
        const tuple = {
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "admin",
          object: "workspace:1",
        };
        const scope = nocks.delete(baseConfig.storeId!, tuple);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.write({
          deletes: { tuple_keys: [tuple] },
        });

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({});
      });
    });

    describe("expand", () => {
      it("should properly pass the errors that the Auth0 Fine Grained Authorization (FGA) API returns", async () => {
        const tuple = {
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "admin",
          object: "workspace:1",
        };
        const scope = nocks.expand(baseConfig.storeId!, tuple);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.expand({ tuple_key: tuple });

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({});
      });
    });

    describe("read", () => {
      it("should properly pass the errors that the Auth0 Fine Grained Authorization (FGA) API returns", async () => {
        const tuple = {
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "admin",
          object: "workspace:1",
        };
        const scope = nocks.read(baseConfig.storeId!, tuple);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.read({ tuple_key: tuple });

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({});
      });
    });

    describe("writeAuthorizationModel", () => {
      it("should call the api and return the response", async () => {
        const authorizationModel = {
          schema_version: "1.1",
          type_definitions: [{ type: "workspace", relations: { admin: { this: {} } } }],
        };
        const scope = nocks.writeAuthorizationModel(baseConfig.storeId!, authorizationModel);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.writeAuthorizationModel(authorizationModel);

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({ id: expect.any(String) });
      });
    });

    describe("readAuthorizationModel", () => {
      it("should call the api and return the response", async () => {
        const configId = "string";
        const scope = nocks.readSingleAuthzModel(baseConfig.storeId!, configId);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.readAuthorizationModel(configId);

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({
          authorization_model: {
            id: expect.any(String),
            schema_version: expect.any(String),
            type_definitions: expect.arrayContaining([]),
          },
        });
      });
    });

    describe("readAuthorizationModels", () => {
      it("should call the api and return the response", async () => {
        const scope = nocks.readAuthorizationModels(baseConfig.storeId!);

        expect(scope.isDone()).toBe(false);
        const data = await auth0FgaApi.readAuthorizationModels();

        expect(scope.isDone()).toBe(true);
        expect(data).toMatchObject({
          authorization_models: expect.arrayContaining([]),
        });
      });
    });

    describe("readChanges", () => {
      it("should call the api and return the response", async () => {
        const type = "repo";
        const pageSize = 25;
        const continuationToken =
          "eyJwayI6IkxBVEVTVF9OU0NPTkZJR19hdXRoMHN0b3JlIiwic2siOiIxem1qbXF3MWZLZExTcUoyN01MdTdqTjh0cWgifQ==";

        const scope = nocks.readChanges(baseConfig.storeId!, type, pageSize, continuationToken);

        expect(scope.isDone()).toBe(false);
        const response = await auth0FgaApi.readChanges(type, pageSize, continuationToken);

        expect(scope.isDone()).toBe(true);
        expect(response).toMatchObject({ changes: expect.arrayContaining([]) });
      });
    });

    describe("listObjects", () => {
      it("should call the api and return the response", async () => {
        const mockedResponse = { objects: ["document:roadmap"] };
        const scope = nocks.listObjects(baseConfig.storeId!, mockedResponse);

        expect(scope.isDone()).toBe(false);
        const response = await auth0FgaApi.listObjects({
          authorization_model_id: "01GAHCE4YVKPQEKZQHT2R89MQV",
          user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
          relation: "can_read",
          type: "document",
          contextual_tuples: {
            tuple_keys: [
              {
                user: "user:81684243-9356-4421-8fbf-a4f8d36aa31b",
                relation: "editor",
                object: "folder:product",
              },
              {
                user: "folder:product",
                relation: "parent",
                object: "document:roadmap",
              },
            ],
          },
        });

        expect(scope.isDone()).toBe(true);
        expect(response.objects).toHaveLength(mockedResponse.objects.length);
        expect(response.objects).toEqual(expect.arrayContaining(mockedResponse.objects));
      });
    });
  });
});
